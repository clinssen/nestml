{#-
simulator.py.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}# generated by {{self._TemplateReference__context.name}}{% endif -%}
"""
simulator.py

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.

Generated from NESTML at time: {{now}}
"""

from typing import List, Mapping, Optional, Union

import numpy as np

from neuron import Neuron


class Simulator:
    neurons: List[Neuron] = []
    connections: Mapping[Neuron, List[Neuron]] = {}       # map from id(source) to list of id(target)
    log: Mapping[str, Mapping[str, List]] = {}
    timestep: float = .1      # should stay constant (static variable), don't change at runtime!


    def __init__(self):
        self._t = 0.       # time [ms]

    def step(self, timestep: float):
        for neuron in self.neurons:
            neuron.step(origin=self._t,
                        timestep=timestep)
            if not neuron.get_model() in self.log.keys():
                self.log[neuron.get_model()] = {}  # map from variable names to list of values
            if not "t" in self.log.keys():
                self.log["t"] = []
            if "S_" in dir(neuron):
                self.log[neuron.get_model()].append(S_)
            self.log["t"].append(self._t)


    def add_neuron(self, neuron: Neuron) -> int:
        r"""Add neuron instance to the simulator. Return a globally unique neuron ID for this instance."""
        self.neurons.append(neuron)
        return len(self.neurons) - 1


    def connect(self, source: int, target: int) -> None:
        r"""Connect a source and target neuron, passed as instances"""
        if not source in self.connections.keys():
            self.connections[source]: List[int] = []   # list of id_target

        self.connections[source].append(target)


    def handle(self, source: Neuron) -> None:
        r"""Handle incoming spike"""
        self._incoming_spike_buffer.append(source)


    def deliver_spikes(self) -> None:
        r"""Deliver spikes in the queue"""
        for source in self.neurons:
            for t_spike in neuron.pop_emitted_spikes():
                for target in self.connections[source]:
                    self.neurons[source].handle(t_spike)

        self._incoming_spike_buffer = []


    def run(self, t_stop: float):
        r"""Run the simulation.

        Parameters
        ----------
        t_stop
            Stopping time in milliseconds.
        """
        self.t = 0.
        while self.t < t_stop:
            self.step(self.timestep)
            self.deliver_spikes()
            self.t += self.timestep
