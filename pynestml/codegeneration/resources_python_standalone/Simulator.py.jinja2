{#-
Simulator.py.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.
#}
{%- if tracing %}# generated by {{self._TemplateReference__context.name}}{% endif -%}
"""
Simulator.py

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http://www.gnu.org/licenses/>.

Generated from NESTML at time: {{now}}
"""

from typing import Optional

import numpy as np
from abc import ABCMeta, abstractmethod



class Neuron(metaclass=ABCMeta):
    @abstractmethod
    def update(self, origin: float) -> None:
        pass

    @abstractmethod
    def handle(self, port_name: str) -> None:
        pass

{%- for neuron in neurons %}
from {{neuron.name}} import Neuron_{{neuron.name}}
{%- endfor %}


class Simulator:
    neurons: List[Neuron] = []
    connections: Map[Neuron, List[Neuron]] = {}       # map from id(source) to list of id(target)
    log: Mapping[str, Mapping[str, List]] = {}
    timestep: float = .1      # should stay constant (static variable), don't change at runtime!


    def __init__(self):
        self._t = 0.       # time [ms]


    def steps(self, time_ms: float):
        r"""Convert a time period (in milliseconds) to number of simulation steps"""
        return int(np.ceil(time_ms / self.timestep))


    def step(self):
        for neuron in self.neurons:
            neuron.update(self._t)
            if not neuron.get_name() in self.log.keys():
                self.log[neuron.get_name()] = {}  # map from variable names to list of values
                self.log[neuron.get_name()]["t"] = []
            self.log[neuron.get_name()].append()
            self.log["t"].append(self._t)


    def add_neuron(self, neuron: Neuron) -> int:
        r"""Add neuron instance to the simulator. Return a globally unique neuron ID for this instance."""
        self.neurons.append(neuron)
        return len(self.neurons) - 1


    def connect(self, source: int, target: int) -> None:
        r"""Connect a source and target neuron, passed as instances"""
        if not source in self.connections.keys():
            self.connections[source]: List[Neuron] = []   # list of id(target)

        self.connections[id(source)].append(id(target))


    def handle(self, source: Neuron) -> None:
        r"""Handle incoming spike"""
        self._incoming_spike_buffer.append(source)


    def deliver_spikes(self) -> None:
        r"""Deliver spikes in the queue"""
        for source in self._incoming_spike_buffer:
            self.neurons[source].handle(self._t)

        self._incoming_spike_buffer = []


    def run(self, t_stop: float):
        r"""Run the simulation.

        Parameters
        ----------
        t_stop
            Stopping time in milliseconds.
        """
        self.t = 0.
        while self.t < t_stop:
            self.deliver_spikes()
            self.step()
            self.t += self.timestep


class SpikeGenerator(Neuron):
  def __init__(self, simulator: Simulator):
    t_spikes = [simulator.t_stop / 4,
                3 * simulator.t_stop / 4]
    self._interval = 10.
    self._interval_counter = self._interval

  def update(self, t: float):
    if t > self._interval_counter:
      # emit a spike!
      self._interval_counter += self._interval
      Simulator.handle(self)


def __main__(self):
    simulator = Simulator()

    sg = simulator.add_neuron(SpikeGenerator())

{%- for neuron in neurons %}
    neuron = simulator.add_neuron(Neuron_{{neuron.name}}())

    simulator.connect(sg, neuron)
{%- endfor %}

    simulator.run(100.)