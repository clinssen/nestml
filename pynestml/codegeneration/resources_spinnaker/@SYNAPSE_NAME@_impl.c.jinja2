#ifndef _{{synapseName.upper()}}_H_
#define _{{synapseName.upper()}}_H_


#include <debug.h>
#include <utils.h>
#include <neuron/synapses.h>
#include <neuron/plasticity/synapse_dynamics.h>

#ifndef SYNAPSE_AXONAL_DELAY_BITS
#define SYNAPSE_AXONAL_DELAY_BITS 3
#endif

#define SYNAPSE_AXONAL_DELAY_MASK \
    ((1 << SYNAPSE_AXONAL_DELAY_BITS) - 1)

typedef struct {
    //! The event time
} pre_event_history_t;

typedef struct stdp_params {
    //! The back-propagation delay, in basic simulation timesteps
    uint32_t backprop_delay;
} stdp_params;

typedef struct fixed_stdp_synapse {
    uint32_t delay_dendritic;
    uint32_t delay_axonal;
    uint32_t type;
    uint32_t index;
    uint32_t type_index;
    uint32_t ring_buffer_index;
} fixed_stdp_synapse;

//! Configuration parameters
static stdp_params params;

//! \brief The history data of post-events
// static post_event_history_t *post_event_history;

//! Count of pre-synaptic events relevant to plastic processing
static uint32_t num_plastic_pre_synaptic_events = 0;

//! Count of times that the plastic math became saturated
static uint32_t plastic_saturation_count = 0;

/* PRIVATE FUNCTIONS */

// Mark a value as possibly unused while not using any instructions, guaranteed
#ifndef __use
#define __use(x)    do { (void) (x); } while (0)
#endif

/*** SYNAPTIC DYNAMICS ***/
// => Entrypoint for system calls

//System called (c_main_synapse_common.h)
bool synapse_dynamics_initialise(
        address_t address, uint32_t n_neurons, uint32_t n_synapse_types,
        uint32_t *ring_buffer_to_input_buffer_left_shifts){
	return true;			
}

//System called (synapses.c)
bool synapse_dynamics_process_plastic_synapses(
        synapse_row_plastic_data_t *plastic_region_data,
        synapse_row_fixed_part_t *fixed_region,
        weight_t *ring_buffers, uint32_t time, uint32_t colour_delay,
        bool *write_back){
    *write_back = false;
    return false;
}

//System called (send_spike.h)
void synapse_dynamics_process_post_synaptic_event(
        uint32_t time, index_t neuron_index){
	return;
}


//System called (synapses.c)
void synapse_dynamics_print_plastic_synapses(
        synapse_row_plastic_data_t *plastic_region_data,
        synapse_row_fixed_part_t *fixed_region,
        uint32_t *ring_buffer_to_input_buffer_left_shifts){

}

//System called (synapses.c)
uint32_t synapse_dynamics_get_plastic_pre_synaptic_events(void){
	return 0;
}

//System called (c_main_synapse_common.h)
uint32_t synapse_dynamics_get_plastic_saturation_count(void){
	return 0;
}

//Border zone (topographic_map_impl.c) -> neuromodulation only
bool synapse_dynamics_find_neuron(
        uint32_t id, synaptic_row_t row, weight_t *weight, uint16_t *delay,
        uint32_t *offset, uint32_t *synapse_type){
    synapse_row_fixed_part_t *fixed_region = synapse_row_fixed_region(row);
    int32_t fixed_synapse = synapse_row_num_fixed_synapses(fixed_region);
    uint32_t *synaptic_words = synapse_row_fixed_weight_controls(fixed_region);

    // Loop through plastic synapses
    for (; fixed_synapse > 0; fixed_synapse--) {

        // Get next control word (auto incrementing)
        // Check if index is the one I'm looking for
        uint32_t synaptic_word = *synaptic_words++;
        if (synapse_row_sparse_index(synaptic_word, synapse_index_mask) == id) {
            *offset = synapse_row_num_fixed_synapses(fixed_region) -
                    fixed_synapse;
            *weight = synapse_row_sparse_weight(synaptic_word);
            *delay = synapse_row_sparse_delay(synaptic_word,
                    synapse_type_index_bits, synapse_delay_mask);
            *synapse_type = synapse_row_sparse_type(
                    synaptic_word, synapse_index_bits, synapse_type_mask);
            return true;
        }
    }

    return false;
}

//Border zone (sp_structs.h) -> neuromodulation only
bool synapse_dynamics_remove_neuron(uint32_t offset, synaptic_row_t row){
    synapse_row_fixed_part_t *fixed_region = synapse_row_fixed_region(row);
    int32_t fixed_synapse = synapse_row_num_fixed_synapses(fixed_region);
    uint32_t *synaptic_words = synapse_row_fixed_weight_controls(fixed_region);

    // Delete control word at offset (contains weight)
    synaptic_words[offset] = synaptic_words[fixed_synapse - 1];

    // Decrement FF
    fixed_region->num_fixed--;
    return true;
}

//TODO: Remove, not from API only for testing
//! packing all of the information into the required static control word
static inline uint32_t _fixed_synapse_convert(
        uint32_t id, weight_t weight, uint32_t delay, uint32_t type) {
    uint32_t new_synapse = weight << (32 - SYNAPSE_WEIGHT_BITS);
    new_synapse |= ((delay & ((1 << synapse_delay_bits) - 1)) <<
            synapse_type_index_bits);
    new_synapse |= ((type & ((1 << synapse_type_bits) - 1)) <<
            synapse_index_bits);
    new_synapse |= (id & ((1 << synapse_type_index_bits) - 1));
    return new_synapse;
}

//Border zone (sp_structs.h) -> neuromodulation only
bool synapse_dynamics_add_neuron(
        uint32_t id, synaptic_row_t row, weight_t weight,
        uint32_t delay, uint32_t type){
    synapse_row_fixed_part_t *fixed_region = synapse_row_fixed_region(row);
    int32_t fixed_synapse = synapse_row_num_fixed_synapses(fixed_region);
    uint32_t *synaptic_words = synapse_row_fixed_weight_controls(fixed_region);
    uint32_t new_synapse = _fixed_synapse_convert(id, weight, delay, type);
	    // Add control word at offset
    synaptic_words[fixed_synapse] = new_synapse;

    // Increment FF
    fixed_region->num_fixed++;
    return true;
}

//Border zone (topographic_map_impl.c) -> neuromodulation only
uint32_t synapse_dynamics_n_connections_in_row(synapse_row_fixed_part_t *fixed){
	return synapse_row_num_fixed_synapses(fixed);;
}

#endif // _{{synapseName.upper()}}_H_