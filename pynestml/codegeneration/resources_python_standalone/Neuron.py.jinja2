{#-
Neuron.py.jinja2

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http:#www.gnu.org/licenses/>.
#}
"""
{{neuronName}}.py

This file is part of NEST.

Copyright (C) 2004 The NEST Initiative

NEST is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 2 of the License, or
(at your option) any later version.

NEST is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with NEST.  If not, see <http:#www.gnu.org/licenses/>.

Generated from NESTML at time: {{now}}
"""

{% if tracing %}# generated by {{self._TemplateReference__context.name}}
{% endif -%}

DEBUG = 1

import numpy as np

from Neuron import Neuron


{%- set stateSize = neuron.get_non_inline_state_symbols()|length %}

class Neuron_{{neuronName}}(Neuron):

  class Parameters_:
{%- filter indent(4,True) %}
{%- for variable in neuron.get_parameter_symbols() %}
{%- include 'directives/MemberDeclaration.jinja2' %}
{%- endfor %}
{%- endfilter %}

  class State_:
{%- filter indent(4,True) %}
{%- for variable in neuron.get_state_symbols() %}
{%- include 'directives/MemberDeclaration.jinja2' %}
{%- endfor %}
{%- endfilter %}

  def __init__(self):
    self.__resolution = Simulator.dt

    self.calibrate()
    self.P_ = self.Parameters_()
    self.S_ = self.State_()

{%- if parameter_syms_with_iv|length > 0 %}
    # initial values for parameters
{%- filter indent(4) %}
{%- for parameter in parameter_syms_with_iv %}
{%-   with variable = parameter %}
{%-     include "directives/MemberInitialization.jinja2" %}
{%-   endwith %}
{%- endfor %}
{%- endfilter %}
{%- endif %}

{%- if neuron.get_state_symbols()|length > 0 %}
    # initial values for state variables
{%- filter indent(4) %}
{%- for init in neuron.get_state_symbols() %}
{%-   with variable = init %}
{%-     include "directives/MemberInitialization.jinja2" %}
{%-   endwith %}
{%- endfor %}
{%- endfilter %}
{%- endif %}
{%- if paired_synapse is defined %}
    # state variables for archiving state for paired synapse
    n_incoming_ = 0
    max_delay_ = 0
    last_spike_ = -1.

  # cache initial values
{%- for var in transferred_variables %}
{%- with var_sym = transferred_variables_syms[var] %}
{%- if not var == var_sym.get_symbol_name() %}
{{ raise('Error in resolving variable to symbol') }}
{%- endif %}
  {{var}}__iv = {{names.getter(var_sym)}}()
{%- endwith %}
{%- endfor %}
{%- endif %}

{%- if paired_neuron is defined %}
    self.clear_history()
{%- endif %}

  def get_name(self) -> str:
    return "{{neuronName}}";

  def calibrate_variables(self, exclude_timestep: bool):
    __resolution: float = Simulator.timestep  # do not remove, this is necessary for the resolution() function

    if exclude_timestep:
  {%- filter indent(6,True) %}
  {%- for variable in neuron.get_internal_symbols() %}
  {%- if variable.name != "__h" %}
  {%-   include "directives/Calibrate.jinja2" %}
  {%- endif %}
  {%- endfor %}
  {%- endfilter %}
    else:
      # internals V_
  {%- filter indent(6) %}
  {%- for variable in neuron.get_internal_symbols() %}
  {%-   include "directives/Calibrate.jinja2" %}
  {%- endfor %}
  {%- endfilter %}

  def calibrate(self):
    self.calibrate_variables()

{%- if neuron.get_functions()|length > 0 %}

  # ---------------------------------------------------------------------------
  #   Functions defined in the NESTML model
  # ---------------------------------------------------------------------------
{% for function in neuron.get_functions() -%}
  {{printer.print_function_definition(function, neuronName)}}:
{%-   filter indent(4,True) %}
{%-   with ast = function.get_block() %}
{%-     include "directives/Block.jinja2" %}
{%-   endwith %}
{%-   endfilter %}
{%- endfor %}
{%- endif %}

  # -------------------------------------------------------------------------
  #   Getters/setters for state block
  # -------------------------------------------------------------------------
{% filter indent(2, True) -%}
{%- for state in neuron.get_state_symbols() %}
{%- if not is_delta_kernel(neuron.get_kernel_by_name(state.name)) %}
{%- with variable = state %}
{%- include "directives/MemberVariableGetterSetter.jinja2" %}
{% endwith -%}
{%- endif %}
{%- endfor %}
{%- endfilter %}

  # -------------------------------------------------------------------------
  #   Getters/setters for parameters block
  # -------------------------------------------------------------------------
{% filter indent(2, True) -%}
{%- for parameter in neuron.get_parameter_symbols() %}
{%- with variable = parameter %}
{%- include "directives/MemberVariableGetterSetter.jinja2" %}
{% endwith -%}
{%- endfor %}
{%- endfilter %}

  # -------------------------------------------------------------------------

{%- if uses_numeric_solver %}
{%- include "directives/GSLDifferentiationFunction.jinja2" %}
{%- endif %}

{%- if neuron.get_equations_block() %}
  def _integrate_odes(self):
    r"""Integrate all ODEs defined in the model equation block by one timestep.
    """
{%- filter indent(4) %}
{%-     with analytic_state_variables_ = analytic_state_variables %}
{%-         include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%-     endwith %}
{%-     if uses_numeric_solver %}
{%-        include "directives/GSLIntegrationStep.jinja2" %}
{%-     endif %}
{%-     with analytic_state_variables_ = analytic_state_variables %}
{%-         include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%-     endwith %}
{%- endfilter %}
{%- endif %}

  def update(self, origin: float):
    __resolution: float = Simulator.timestep   # do not remove, this is necessary for the resolution() function

    # NESTML generated code for the update block:

{%- if neuron.get_update_blocks() %}
{%- filter indent(4) %}
{%- set dynamics = neuron.get_update_blocks() %}
{%- with ast = dynamics.get_block() %}
{%-   include "directives/Block.jinja2" %}
{%- endwith %}
{%- endfilter %}
{%- endif %}

{% if has_spike_input %}
  # -------------------------------------------------------------------------
  #   Spiking input handlers
  # -------------------------------------------------------------------------

  def handle(self, port_name: str) -> None:
{%   for port in neuron.get_spike_input_ports() %}
    if port_name == "{{port.name}}":
{%-     filter indent(6) %}
{%-     for ast in spike_updates[port.name] %}
{%-       include "directives/Assignment.jinja2" %}
{%-     endfor %}
{%-     endfilter %}
{%   endfor %}

  def get_spiking_input_ports(self) -> List[str]:
    return [
{%- for port in neuron.get_spike_input_ports() %}
            "{{port.name}}",
{%- endfor %}
    ]

{%- endif %}

{%- if paired_synapse is defined %}
  # -------------------------------------------------------------------------
  #   Synapse co-generation
  # -------------------------------------------------------------------------
  def get_spiketime_ms(self):
    return last_spike_

  def register_stdp_connection(self, t_first_read: float, delay: float):
    # Mark all entries in the deque, which we will not read in future as read by
    # this input input, so that we safely increment the incoming number of
    # connections afterwards without leaving spikes in the history.
    # For details see bug #218. MH 08-04-22

    for ( std::deque< histentry__{{neuronName}} >::iterator runner = history_.begin();
        runner != history_.end() and ( t_first_read - runner->t_ > -1.0 * nest::kernel().connection_manager.get_stdp_eps() );
        ++runner )
      runner->access_counter_ += 1

    n_incoming_ += 1
    max_delay_ = max(delay, max_delay_)

  def get_history__(t1: float, t2: float):
    *finish = history_.end();
    if ( history_.empty() )
    {
      *start = *finish;
      return;
    }
    std::deque< histentry__{{neuronName}} >::reverse_iterator runner = history_.rbegin();
    const double t2_lim = t2 + nest::kernel().connection_manager.get_stdp_eps();
    const double t1_lim = t1 + nest::kernel().connection_manager.get_stdp_eps();
    while ( runner != history_.rend() and runner->t_ >= t2_lim )
    {
      ++runner;
    }
    *finish = runner.base();
    while ( runner != history_.rend() and runner->t_ >= t1_lim )
    {
      runner->access_counter_++;
      ++runner;
    }
    *start = runner.base();

  def set_spiketime(t_sp: float, offset: float):
    num_transferred_variables: int = 0
{%- for var in transferred_variables %}
    num_transferred_variables += 1
{%- endfor %}

    t_sp_ms = t_sp - offset

    if n_incoming_:
        # prune all spikes from history which are no longer needed
        # only remove a spike if:
        # - its access counter indicates it has been read out by all connected
        #     STDP synapses, and
        # - there is another, later spike, that is strictly more than
        #     (max_delay_ + eps) away from the new spike (at t_sp_ms)
        while len(self.history_) > 1:
            const double next_t_sp = history_[ 1 ].t_
            if ( history_.front().access_counter_ >= n_incoming_ * num_transferred_variables
                and t_sp_ms - next_t_sp > max_delay_ + nest::kernel().connection_manager.get_stdp_eps() )
            {
                history_.pop_front();
            }
            else
            {
                break;
            }
        }

        if (history_.size() > 0) {
            assert(history_.back().t_ == last_spike_);

{%- for var in purely_numeric_state_variables_moved|sort %}
            S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = history_.back().{{var}}_;
{%- endfor %}
{%- for var in analytic_state_variables_moved|sort %}
            S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = history_.back().{{var}}_;
{%- endfor %}
        }
        else {
{%- for var in purely_numeric_state_variables_moved|sort %}
            S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = 0.; # initial value for convolution is always 0
{%- endfor %}
{%- for var in analytic_state_variables_moved|sort %}
            S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var, SymbolKind.VARIABLE))}} = 0.; # initial value for convolution is always 0
{%- endfor %}
        }



        # update state variables transferred from synapse from `last_spike_` to `t_sp_ms`

        const double old___h = self.V_.__h;
        self.V_.__h = t_sp_ms - last_spike_;
        if (self.V_.__h > 1E-12) {
          calibrate_variables(true);

#  Generates a series of C++ statements which perform one integration step of all ODEs that are solved by the analytic integrator.


{%- filter indent(6, True) %}
{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%- endwith %}

{%- if uses_numeric_solver %}
# update only synapse->neuron moved variables; back-up and restore the rest
double ode_state_bak[State_::STATE_VEC_SIZE];

{%-   for variable_name in numeric_state_variables %}
ode_state_bak[State_::{{variable_name}}] = S_.ode_state[State_::{{variable_name}}];
{%-     endfor %}

{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}
{%- endif %}

# restore non-synapse->neuron-moved variables
{%-   for variable_name in numeric_state_variables %}
S_.ode_state[State_::{{variable_name}}] = ode_state_bak[State_::{{variable_name}}];
{%-     endfor %}

# restore variables solved analytically
{%-   for variable_name in numeric_state_variables %}
S_.ode_state[State_::{{variable_name}}] = ode_state_bak[State_::{{variable_name}}];
{%-     endfor %}

{%- endif %}

{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%- endwith %}

{%- endfilter %}
        V_.__h = old___h;
        calibrate_variables(true);
      }

        /**
         * apply spike updates
        **/

{%- for stmt in spike_update_stmts %}
{%- if uses_numeric_solver %}
        {{printer.print_node(stmt)}};
{%- else %}
        {{nest_printer.print_node(stmt)}};
{%- endif %}
{%- endfor %}

{%- for _, spike_update in post_spike_updates.items() %}
        S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(spike_update.get_variable().get_complete_name(), SymbolKind.VARIABLE))}} += 1.;
{%- endfor %}

    last_spike_ = t_sp_ms;
    history_.push_back( histentry__{{neuronName}}( last_spike_
{%- for var in purely_numeric_state_variables_moved|sort %}
    , get_{{var}}()
{%- endfor %}
{%- for var in analytic_state_variables_moved|sort %}
    , get_{{var}}()
{%- endfor %}
, 0
 ) );
  }
  else
  {
    last_spike_ = t_sp_ms;
  }
}


void
{{neuronName}}::clear_history()
{
  last_spike_ = -1.0;
  history_.clear();
}


#	generate getter functions for the transferred variables


{%- for var in transferred_variables %}
{%- with var_sym = transferred_variables_syms[var] %}

{%- if not var == var_sym.get_symbol_name() %}
{{ raise('Error in resolving variable to symbol') }}
{%- endif %}

double
{{neuronName}}::get_{{var}}( double t, const bool before_increment )
{
#ifdef DEBUG
  std::cout << "{{neuronName}}::get_{{var}}: getting value at t = " << t << std::endl;
#endif

  # case when the neuron has not yet spiked
  if ( history_.empty() )
  {
#ifdef DEBUG
    std::cout << "{{neuronName}}::get_{{var}}: \thistory empty, returning initial value = " << {{var}}__iv << std::endl;
#endif
    # return initial value
    return {{var}}__iv;
  }

  # search for the latest post spike in the history buffer that came strictly before `t`
  int i = history_.size() - 1;
  double eps = 0.;
  if ( before_increment ) {
   eps = nest::kernel().connection_manager.get_stdp_eps();
  }
  while ( i >= 0 )
  {
    if ( t - history_[ i ].t_ >= eps )
    {
#ifdef DEBUG
      std::cout<<"{{neuronName}}::get_{{var}}: \tspike occurred at history[i].t_ = " << history_[i].t_ << std::endl;
#endif

{%- for var_ in purely_numeric_state_variables_moved %}
      S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = history_[ i ].{{var_}}_;
{%- endfor %}
{%- for var_ in analytic_state_variables_moved %}
      S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = history_[ i ].{{var_}}_;
{%- endfor %}

      /**
       * update state variables transferred from synapse from `history[i].t_` to `t`
      **/

      if ( t - history_[ i ].t_ >= nest::kernel().connection_manager.get_stdp_eps() )
      {
        const double old___h = V_.__h;
        V_.__h = t - history_[i].t_;
        assert(V_.__h > 0);
        calibrate_variables(true);

#  Generates a series of C++ statements which perform one integration step of all ODEs that are solved by the analytic integrator.


{%- filter indent(6, True) %}
{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%- endwith %}

{%- if purely_numeric_state_variables_moved|length > 0 %}
double ode_state_tmp[STATE_VEC_SIZE];

for (int i = 0; i < STATE_VEC_SIZE; ++i) {
  ode_state_tmp[i] = S_.ode_state[i];
}

{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}
{%- endif %}

{%- for variable_name in numeric_state_variables_moved|sort %}
{%- if not variable_name in analytic_state_variables_moved %}
S_.ode_state[State_::{{variable_name}}] = ode_state_tmp[State_::{{variable_name}}];
{%- endif %}
{%- endfor %}
{%- endif %}

{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%- endwith %}
{%- endfilter %}

        V_.__h = old___h;
        calibrate_variables(true);
      }

#ifdef DEBUG
      std::cout << "{{neuronName}}::get_{{var}}: \treturning " << {{names.getter(var_sym)}}() << std::endl;
#endif
      return {{names.getter(var_sym)}}();       # type: {{declarations.print_variable_type(var_sym)}}
    }
    --i;
  }

  # this case occurs when the trace was requested at a time precisely at that of the first spike in the history
  if ( (!before_increment) && t == history_[ 0 ].t_)
  {
{%- for var_ in purely_numeric_state_variables_moved %}
    S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = history_[ 0 ].{{var_}}_;
{%- endfor %}
{%- for var_ in analytic_state_variables_moved %}
    S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = history_[ 0 ].{{var_}}_;
{%- endfor %}

#ifdef DEBUG
    std::cout << "{{neuronName}}::get_{{var}}: \ttrace requested at exact time of history entry 0, returning " << {{names.getter(var_sym)}}() << std::endl;
#endif
    return {{names.getter(var_sym)}}();
  }

  # this case occurs when the trace was requested at a time before the first spike in the history
  # return initial value propagated in time
#ifdef DEBUG
  std::cout << "{{neuronName}}::get_{{var}}: \tfall-through, returning initial value = " << {{var}}__iv << std::endl;
#endif

  if (t == 0.) {
    return 0.;  # initial value for convolution is always 0
  }

  # set to initial value
{%- for var_ in purely_numeric_state_variables_moved %}
  S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = 0.;  # initial value for convolution is always 0
{%- endfor %}
{%- for var_ in analytic_state_variables_moved %}
  S_.{{names.name(neuron.get_equations_block().get_scope().resolve_to_symbol(var_, SymbolKind.VARIABLE))}} = 0.;  # initial value for convolution is always 0
{%- endfor %}

  # propagate in time
  const double old___h = V_.__h;
  V_.__h = t;   # from time 0 to the requested time
  assert(V_.__h > 0);
  calibrate_variables(true);

  # Generates a series of C++ statements which perform one integration step of all ODEs that are solved by the analytic integrator.
{%- filter indent(2, True) %}
{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_begin.jinja2" %}
{%- endwith %}

{%- if purely_numeric_state_variables_moved|length > 0 %}
double ode_state_tmp[STATE_VEC_SIZE];

for (int i = 0; i < STATE_VEC_SIZE; ++i) {
    ode_state_tmp[i] = S_.ode_state[i];
}

{%- if uses_numeric_solver %}
{%-     include "directives/GSLIntegrationStep.jinja2" %}
{%- endif %}

{%- for variable_name in numeric_state_variables_moved|sort %}
{%- if not variable_name in analytic_state_variables_moved %}
  S_.ode_state[State_::{{variable_name}}] = ode_state_tmp[State_::{{variable_name}}];
{%- endif %}
{%- endfor %}
{%- endif %}

{%- with analytic_state_variables_ = analytic_state_variables_moved|sort %}
{%-     include "directives/AnalyticIntegrationStep_end.jinja2" %}
{%- endwith %}

{%- endfilter %}
  V_.__h = old___h;
  calibrate_variables(true);

  return {{names.getter(var_sym)}}();
}
{%- endwith -%}
{%- endfor %}

{%- endif %}
