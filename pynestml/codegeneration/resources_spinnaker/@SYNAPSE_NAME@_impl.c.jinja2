#ifndef _{{synapseName.upper()}}_H_
#define _{{synapseName.upper()}}_H_

#include <neuron/synapses.h>
#include <neuron/synapse_row.h>

#include <neuron/plasticity/synapse_dynamics.h>

#ifndef SYNAPSE_AXONAL_DELAY_BITS
#define SYNAPSE_AXONAL_DELAY_BITS 3
#endif

#define SYNAPSE_AXONAL_DELAY_MASK \
    ((1 << SYNAPSE_AXONAL_DELAY_BITS) - 1)

typedef struct {
    //! The event time
    uint32_t prev_time;
    //! The event trace
    pre_trace_t prev_trace;
} pre_event_history_t;

typedef struct stdp_params {
    //! The back-propagation delay, in basic simulation timesteps
    uint32_t backprop_delay;
} stdp_params;

typedef struct fixed_stdp_synapse {
    uint32_t delay_dendritic;
    uint32_t delay_axonal;
    uint32_t type;
    uint32_t index;
    uint32_t type_index;
    uint32_t ring_buffer_index;
} fixed_stdp_synapse;

//! Configuration parameters
static stdp_params params;

//! \brief The history data of post-events
static post_event_history_t *post_event_history;

//! Count of pre-synaptic events relevant to plastic processing
static uint32_t num_plastic_pre_synaptic_events = 0;

//! Count of times that the plastic math became saturated
static uint32_t plastic_saturation_count = 0;

/* PRIVATE FUNCTIONS */

// Mark a value as possibly unused while not using any instructions, guaranteed
#ifndef __use
#define __use(x)    do { (void) (x); } while (0)
#endif

/*** SYNAPTIC DYNAMICS ***/
// => Entrypoint for system calls

//System called (c_main_synapse_common.h)
bool synapse_dynamics_initialise(
        address_t address, uint32_t n_neurons, uint32_t n_synapse_types,
        uint32_t *ring_buffer_to_input_buffer_left_shifts){
	return true;			
}

//System called (synapses.c)
bool synapse_dynamics_process_plastic_synapses(
        synapse_row_plastic_data_t *plastic_region_data,
        synapse_row_fixed_part_t *fixed_region,
        weight_t *ring_buffers, uint32_t time, uint32_t colour_delay,
        bool *write_back){
	return true;
}

//System called (send_spike.h)
void synapse_dynamics_process_post_synaptic_event(
        uint32_t time, index_t neuron_index){
	return;
}


//System called (synapses.c)
void synapse_dynamics_print_plastic_synapses(
        synapse_row_plastic_data_t *plastic_region_data,
        synapse_row_fixed_part_t *fixed_region,
        uint32_t *ring_buffer_to_input_buffer_left_shifts){
	return;
}

//System called (synapses.c)
uint32_t synapse_dynamics_get_plastic_pre_synaptic_events(void){
	return 0;
}

//System called (c_main_synapse_common.h)
uint32_t synapse_dynamics_get_plastic_saturation_count(void){
	return 0;
}

//Border zone (topographic_map_impl.c) -> neuromodulation only
bool synapse_dynamics_find_neuron(
        uint32_t id, synaptic_row_t row, weight_t *weight, uint16_t *delay,
        uint32_t *offset, uint32_t *synapse_type){
	return false;
}

//Border zone (sp_structs.h) -> neuromodulation only
bool synapse_dynamics_remove_neuron(uint32_t offset, synaptic_row_t row){
	return true;
}

//Border zone (sp_structs.h) -> neuromodulation only
bool synapse_dynamics_add_neuron(
        uint32_t id, synaptic_row_t row, weight_t weight,
        uint32_t delay, uint32_t type){
	return true;
}

//Border zone (topographic_map_impl.c) -> neuromodulation only
uint32_t synapse_dynamics_n_connections_in_row(synapse_row_fixed_part_t *fixed){
	return 0;
}

#endif // _{{synapseName.upper()}}_H_